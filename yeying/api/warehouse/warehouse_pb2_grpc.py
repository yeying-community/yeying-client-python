# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from yeying.api.warehouse import warehouse_pb2 as yeying_dot_api_dot_warehouse_dot_warehouse__pb2

GRPC_GENERATED_VERSION = "1.68.1"
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower

    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f"The grpc package installed is at version {GRPC_VERSION},"
        + f" but the generated code in yeying/api/warehouse/warehouse_pb2_grpc.py depends on"
        + f" grpcio>={GRPC_GENERATED_VERSION}."
        + f" Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}"
        + f" or downgrade your generated code using grpcio-tools<={GRPC_VERSION}."
    )


class WarehouseStub(object):
    """*

    开放的分散式仓库网络的接口设计，参考了现实世界中的仓库，逻辑如下：
    1、数字资产有两个标识，一个是数字资产的身份标识，可以是分布式数字身份，也可以是用户自定义的身份ID，另一个是数字资产内容的哈希值；
    2、数字资产入库，发送到指定存储网络中的节点，可以指定副本数量，一方面保证内容不会因为单个节点故障而丢失，另外也保证内容的可访问性；
    3、存储复用，如果两份资产哈希值一样，分两种情况来看，如果资产的所有者一样，则仓库会主动告知身份持有者存在重复，如果资产的所有者不同，会增加引用；
    4、授权数字资产，所有者和使用者立交易关系，确保使用者根据指定的策略访问数据，仓库会统计数字资产的使用情况，比如统计内容取（浏览）的次数评估内容热度
    ，或者统计内容存的次数（收藏）评估内容质量，目的是更好的分配存储资源；

    分散式存储网络的使用场景：
    1、创作场景，知识产权证明
    2、代码包分发场景，比如软件包，模型包等
    3、数字资产，类似nft等
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.GetState = channel.unary_unary(
            "/yeying.api.store.Warehouse/GetState",
            request_serializer=yeying_dot_api_dot_warehouse_dot_warehouse__pb2.GetStateRequest.SerializeToString,
            response_deserializer=yeying_dot_api_dot_warehouse_dot_warehouse__pb2.GetStateResponse.FromString,
            _registered_method=True,
        )
        self.Transfer = channel.unary_unary(
            "/yeying.api.store.Warehouse/Transfer",
            request_serializer=yeying_dot_api_dot_warehouse_dot_warehouse__pb2.TransferRequest.SerializeToString,
            response_deserializer=yeying_dot_api_dot_warehouse_dot_warehouse__pb2.GetStateResponse.FromString,
            _registered_method=True,
        )


class WarehouseServicer(object):
    """*

    开放的分散式仓库网络的接口设计，参考了现实世界中的仓库，逻辑如下：
    1、数字资产有两个标识，一个是数字资产的身份标识，可以是分布式数字身份，也可以是用户自定义的身份ID，另一个是数字资产内容的哈希值；
    2、数字资产入库，发送到指定存储网络中的节点，可以指定副本数量，一方面保证内容不会因为单个节点故障而丢失，另外也保证内容的可访问性；
    3、存储复用，如果两份资产哈希值一样，分两种情况来看，如果资产的所有者一样，则仓库会主动告知身份持有者存在重复，如果资产的所有者不同，会增加引用；
    4、授权数字资产，所有者和使用者立交易关系，确保使用者根据指定的策略访问数据，仓库会统计数字资产的使用情况，比如统计内容取（浏览）的次数评估内容热度
    ，或者统计内容存的次数（收藏）评估内容质量，目的是更好的分配存储资源；

    分散式存储网络的使用场景：
    1、创作场景，知识产权证明
    2、代码包分发场景，比如软件包，模型包等
    3、数字资产，类似nft等
    """

    def GetState(self, request, context):
        """*
        仓库和仓库之间同步数字资产，或者用户和仓库者之间
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details("Method not implemented!")
        raise NotImplementedError("Method not implemented!")

    def Transfer(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details("Method not implemented!")
        raise NotImplementedError("Method not implemented!")


def add_WarehouseServicer_to_server(servicer, server):
    rpc_method_handlers = {
        "GetState": grpc.unary_unary_rpc_method_handler(
            servicer.GetState,
            request_deserializer=yeying_dot_api_dot_warehouse_dot_warehouse__pb2.GetStateRequest.FromString,
            response_serializer=yeying_dot_api_dot_warehouse_dot_warehouse__pb2.GetStateResponse.SerializeToString,
        ),
        "Transfer": grpc.unary_unary_rpc_method_handler(
            servicer.Transfer,
            request_deserializer=yeying_dot_api_dot_warehouse_dot_warehouse__pb2.TransferRequest.FromString,
            response_serializer=yeying_dot_api_dot_warehouse_dot_warehouse__pb2.GetStateResponse.SerializeToString,
        ),
    }
    generic_handler = grpc.method_handlers_generic_handler("yeying.api.store.Warehouse", rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers("yeying.api.store.Warehouse", rpc_method_handlers)


# This class is part of an EXPERIMENTAL API.
class Warehouse(object):
    """*

    开放的分散式仓库网络的接口设计，参考了现实世界中的仓库，逻辑如下：
    1、数字资产有两个标识，一个是数字资产的身份标识，可以是分布式数字身份，也可以是用户自定义的身份ID，另一个是数字资产内容的哈希值；
    2、数字资产入库，发送到指定存储网络中的节点，可以指定副本数量，一方面保证内容不会因为单个节点故障而丢失，另外也保证内容的可访问性；
    3、存储复用，如果两份资产哈希值一样，分两种情况来看，如果资产的所有者一样，则仓库会主动告知身份持有者存在重复，如果资产的所有者不同，会增加引用；
    4、授权数字资产，所有者和使用者立交易关系，确保使用者根据指定的策略访问数据，仓库会统计数字资产的使用情况，比如统计内容取（浏览）的次数评估内容热度
    ，或者统计内容存的次数（收藏）评估内容质量，目的是更好的分配存储资源；

    分散式存储网络的使用场景：
    1、创作场景，知识产权证明
    2、代码包分发场景，比如软件包，模型包等
    3、数字资产，类似nft等
    """

    @staticmethod
    def GetState(
        request,
        target,
        options=(),
        channel_credentials=None,
        call_credentials=None,
        insecure=False,
        compression=None,
        wait_for_ready=None,
        timeout=None,
        metadata=None,
    ):
        return grpc.experimental.unary_unary(
            request,
            target,
            "/yeying.api.store.Warehouse/GetState",
            yeying_dot_api_dot_warehouse_dot_warehouse__pb2.GetStateRequest.SerializeToString,
            yeying_dot_api_dot_warehouse_dot_warehouse__pb2.GetStateResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True,
        )

    @staticmethod
    def Transfer(
        request,
        target,
        options=(),
        channel_credentials=None,
        call_credentials=None,
        insecure=False,
        compression=None,
        wait_for_ready=None,
        timeout=None,
        metadata=None,
    ):
        return grpc.experimental.unary_unary(
            request,
            target,
            "/yeying.api.store.Warehouse/Transfer",
            yeying_dot_api_dot_warehouse_dot_warehouse__pb2.TransferRequest.SerializeToString,
            yeying_dot_api_dot_warehouse_dot_warehouse__pb2.GetStateResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True,
        )
